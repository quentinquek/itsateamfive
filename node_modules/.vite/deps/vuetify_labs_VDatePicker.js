import {
  VSheet,
  makeVSheetProps
} from "./chunk-UTLXV53Q.js";
import "./chunk-2PSEIA2V.js";
import {
  VSpacer
} from "./chunk-PXYNJGYF.js";
import "./chunk-G6KDFCY5.js";
import {
  VTextField
} from "./chunk-MMFU4F3K.js";
import "./chunk-XV4QSM4Q.js";
import "./chunk-3PAHN357.js";
import "./chunk-LRLMAPYZ.js";
import "./chunk-GS4XGHAZ.js";
import "./chunk-L3PTSWR5.js";
import {
  VCard
} from "./chunk-7B665DMJ.js";
import "./chunk-3GIHNT7K.js";
import {
  getWeek,
  toIso,
  useDate
} from "./chunk-PVZQNVXV.js";
import "./chunk-GUDXS3QS.js";
import {
  VBtn
} from "./chunk-SSD5HRM4.js";
import "./chunk-GH7FPFEW.js";
import "./chunk-PERYJOTZ.js";
import "./chunk-BUKBX2W4.js";
import {
  VFadeTransition
} from "./chunk-NCIFIG5Y.js";
import "./chunk-7EBM7535.js";
import {
  VDefaultsProvider
} from "./chunk-IHBQHQSH.js";
import "./chunk-QHPYAADC.js";
import "./chunk-TKSYNFJW.js";
import "./chunk-NBJEVV3E.js";
import "./chunk-QBVOO5N3.js";
import "./chunk-IIVM4GZL.js";
import "./chunk-BYYOIPT2.js";
import "./chunk-UBU4KZUY.js";
import "./chunk-6OIYN6EE.js";
import "./chunk-2T3QEACQ.js";
import "./chunk-J4QSHRDK.js";
import "./chunk-OTYFF32L.js";
import "./chunk-EWAMLRLK.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-C3XADYCL.js";
import {
  useLocale
} from "./chunk-NMRZ4LPY.js";
import {
  useProxiedModel
} from "./chunk-4BWECWI4.js";
import "./chunk-TDSCPXFT.js";
import "./chunk-MIKYVDLZ.js";
import "./chunk-OB5CTQGT.js";
import {
  useBackgroundColor
} from "./chunk-Q6VPMTLA.js";
import "./chunk-34YJHVVI.js";
import "./chunk-2V56JD5T.js";
import "./chunk-X7E5QEKA.js";
import {
  EventProp,
  convertToUnit,
  createRange,
  createSimpleFunctional,
  genericComponent,
  omit,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-DB4WMXLI.js";
import {
  Fragment,
  computed,
  createTextVNode,
  createVNode,
  inject,
  mergeProps,
  onMounted,
  provide,
  ref,
  shallowRef,
  toRef,
  watch
} from "./chunk-Y7RJFRXZ.js";
import "./chunk-CO2D5T6V.js";

// node_modules/vuetify/lib/labs/VDatePicker/VDateCard.mjs
import "/Users/Quentin/itsa-team-five/node_modules/vuetify/lib/labs/VDatePicker/VDateCard.css";

// node_modules/vuetify/lib/labs/VDatePicker/VDatePickerControls.mjs
import "/Users/Quentin/itsa-team-five/node_modules/vuetify/lib/labs/VDatePicker/VDatePickerControls.css";
var makeVDatePickerControlsProps = propsFactory({
  displayDate: String,
  disabled: {
    type: [Boolean, String, Array],
    default: false
  },
  nextIcon: {
    type: [String],
    default: "$next"
  },
  prevIcon: {
    type: [String],
    default: "$prev"
  },
  modeIcon: {
    type: [String],
    default: "$subgroup"
  },
  variant: {
    type: String,
    default: "modern"
  },
  viewMode: {
    type: String,
    default: "month"
  }
}, "VDatePickerControls");
var VDatePickerControls = genericComponent()({
  name: "VDatePickerControls",
  props: makeVDatePickerControlsProps(),
  emits: {
    "click:mode": () => true,
    "click:prev": () => true,
    "click:next": () => true
  },
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const disableMode = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("mode") : !!props.disabled;
    });
    const disablePrev = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("prev") : !!props.disabled;
    });
    const disableNext = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("next") : !!props.disabled;
    });
    function onClickPrev() {
      emit("click:prev");
    }
    function onClickNext() {
      emit("click:next");
    }
    function onClickMode() {
      emit("click:mode");
    }
    useRender(() => {
      const displayDate = createVNode("div", {
        "class": "v-date-picker-controls__date"
      }, [props.displayDate]);
      return createVNode("div", {
        "class": ["v-date-picker-controls", `v-date-picker-controls--variant-${props.variant}`]
      }, [props.variant === "modern" && createVNode(Fragment, null, [displayDate, createVNode(VBtn, {
        "key": "mode-btn",
        "disabled": disableMode.value,
        "density": "comfortable",
        "icon": props.modeIcon,
        "variant": "text",
        "onClick": onClickMode
      }, null), createVNode(VSpacer, {
        "key": "mode-spacer"
      }, null)]), createVNode("div", {
        "key": "month-buttons",
        "class": "v-date-picker-controls__month"
      }, [createVNode(VBtn, {
        "disabled": disablePrev.value,
        "icon": props.prevIcon,
        "variant": "text",
        "onClick": onClickPrev
      }, null), props.variant === "classic" && displayDate, createVNode(VBtn, {
        "disabled": disableNext.value,
        "icon": props.nextIcon,
        "variant": "text",
        "onClick": onClickNext
      }, null)])]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VDatePicker/VDatePickerMonth.mjs
import "/Users/Quentin/itsa-team-five/node_modules/vuetify/lib/labs/VDatePicker/VDatePickerMonth.css";

// node_modules/vuetify/lib/labs/VDateInput/composables.mjs
var makeDateProps2 = propsFactory({
  modelValue: {
    type: null,
    default: () => []
  },
  displayDate: {
    type: null,
    default: null
  },
  inputMode: {
    type: String,
    default: "calendar"
  },
  viewMode: {
    type: String,
    default: "month"
  },
  format: String
}, "date");
var dateEmits = {
  "update:modelValue": (date) => true,
  "update:displayDate": (date) => true,
  "update:focused": (focused) => true,
  "update:inputMode": (inputMode) => true,
  "update:viewMode": (viewMode) => true
};
function createDateInput(props, isRange) {
  const adapter = useDate();
  const model = useProxiedModel(props, "modelValue", [], (v) => {
    if (v == null)
      return [];
    const arr = wrapInArray(v).filter((v2) => !!v2);
    return arr.map(adapter.date);
  }, (v) => {
    const arr = wrapInArray(v);
    const formatted = props.format ? arr.map((d) => adapter.format(d, props.format)) : arr;
    if (isRange)
      return formatted;
    return formatted[0];
  });
  const inputMode = useProxiedModel(props, "inputMode");
  const viewMode = useProxiedModel(props, "viewMode");
  const displayDate = useProxiedModel(props, "displayDate", model.value.length ? model.value[0] : adapter.date());
  function parseKeyboardDate(input, fallback) {
    const date = adapter.date(input);
    return adapter.isValid(date) ? date : fallback;
  }
  function isEqual(model2, comparing) {
    if (model2.length !== comparing.length)
      return false;
    for (let i = 0; i < model2.length; i++) {
      if (comparing[i] && !adapter.isEqual(model2[i], comparing[i])) {
        return false;
      }
    }
    return true;
  }
  return {
    model,
    adapter,
    inputMode,
    viewMode,
    displayDate,
    parseKeyboardDate,
    isEqual
  };
}

// node_modules/vuetify/lib/labs/VDatePicker/composables.mjs
var DatePickerSymbol = Symbol.for("vuetify:date-picker");
function createDatePicker(props) {
  const hoverDate = ref();
  const hoverMonth = ref();
  const isDragging = ref(false);
  const dragHandle = ref(null);
  const hasScrolled = ref(false);
  provide(DatePickerSymbol, {
    hoverDate,
    hoverMonth,
    isDragging,
    dragHandle,
    hasScrolled
  });
  const {
    model,
    displayDate,
    viewMode,
    inputMode,
    isEqual
  } = createDateInput(props, !!props.multiple);
  return {
    hoverDate,
    hoverMonth,
    isDragging,
    dragHandle,
    hasScrolled,
    model,
    displayDate,
    viewMode,
    inputMode,
    isEqual
  };
}
function useDatePicker() {
  const datePicker = inject(DatePickerSymbol);
  if (!datePicker)
    throw new Error("foo");
  return datePicker;
}

// node_modules/vuetify/lib/labs/VDatePicker/VDatePickerMonth.mjs
var makeVDatePickerMonthProps = propsFactory({
  color: String,
  showAdjacentMonths: Boolean,
  hideWeekdays: Boolean,
  showWeek: Boolean,
  hoverDate: null,
  multiple: Boolean,
  side: {
    type: String
  },
  min: [Number, String, Date],
  max: [Number, String, Date],
  ...omit(makeDateProps2(), ["inputMode", "viewMode"])
}, "VDatePickerMonth");
var VDatePickerMonth = genericComponent()({
  name: "VDatePickerMonth",
  props: makeVDatePickerMonthProps({
    color: "surface-variant"
  }),
  emits: {
    ...omit(dateEmits, ["update:inputMode", "update:viewMode"]),
    "update:hoverDate": (date) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const adapter = useDate();
    const {
      isDragging,
      dragHandle,
      hasScrolled
    } = useDatePicker();
    const month = computed(() => props.displayDate);
    const findClosestDate = (date, dates) => {
      const {
        isSameDay,
        getDiff
      } = adapter;
      const [startDate, endDate] = dates;
      if (isSameDay(startDate, endDate)) {
        return getDiff(date, startDate, "days") > 0 ? endDate : startDate;
      }
      const distStart = Math.abs(getDiff(date, startDate));
      const distEnd = Math.abs(getDiff(date, endDate));
      return distStart < distEnd ? startDate : endDate;
    };
    const weeksInMonth = computed(() => {
      const weeks2 = adapter.getWeekArray(month.value);
      const days = weeks2.flat();
      const daysInMonth2 = 6 * 7;
      if (days.length < daysInMonth2 && props.showAdjacentMonths) {
        const lastDay = days[days.length - 1];
        let week = [];
        for (let day = 1; day <= daysInMonth2 - days.length; day++) {
          week.push(adapter.addDays(lastDay, day));
          if (day % 7 === 0) {
            weeks2.push(week);
            week = [];
          }
        }
      }
      return weeks2;
    });
    const daysInMonth = computed(() => {
      const validDates = props.modelValue.filter((v) => !!v);
      const isRange = validDates.length > 1;
      const days = weeksInMonth.value.flat();
      const today = adapter.date();
      const startDate = validDates[0];
      const endDate = validDates[1];
      return days.map((date, index) => {
        const isDisabled = !!(props.min && adapter.isAfter(props.min, date) || props.max && adapter.isAfter(date, props.max));
        const isStart = startDate && adapter.isSameDay(date, startDate);
        const isEnd = endDate && adapter.isSameDay(date, endDate);
        const isAdjacent = !adapter.isSameMonth(date, month.value);
        const isSame = validDates.length === 2 && adapter.isSameDay(startDate, endDate);
        return {
          date,
          isoDate: toIso(adapter, date),
          formatted: adapter.format(date, "keyboardDate"),
          year: adapter.getYear(date),
          month: adapter.getMonth(date),
          isDisabled,
          isWeekStart: index % 7 === 0,
          isWeekEnd: index % 7 === 6,
          isSelected: isStart || isEnd,
          isStart,
          isEnd,
          isToday: adapter.isSameDay(date, today),
          isAdjacent,
          isHidden: isAdjacent && !props.showAdjacentMonths,
          inRange: isRange && !isSame && (isStart || isEnd || validDates.length === 2 && adapter.isWithinRange(date, validDates)),
          // isHovered: props.hoverDate === date,
          // inHover: hoverRange.value && isWithinRange(date, hoverRange.value),
          isHovered: false,
          inHover: false,
          localized: adapter.format(date, "dayOfMonth")
        };
      });
    });
    const weeks = computed(() => {
      return weeksInMonth.value.map((week) => {
        return getWeek(adapter, week[0]);
      });
    });
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props, "color");
    function selectDate(date) {
      let newModel = props.modelValue.slice();
      if (props.multiple) {
        if (isDragging.value && dragHandle.value != null) {
          const otherIndex = (dragHandle.value + 1) % 2;
          const fn = otherIndex === 0 ? "isBefore" : "isAfter";
          if (adapter[fn](date, newModel[otherIndex])) {
            newModel[dragHandle.value] = newModel[otherIndex];
            newModel[otherIndex] = date;
            dragHandle.value = otherIndex;
          } else {
            newModel[dragHandle.value] = date;
          }
        } else {
          if (newModel.find((d) => adapter.isSameDay(d, date))) {
            newModel = newModel.filter((v) => !adapter.isSameDay(v, date));
          } else if (newModel.length === 2) {
            let index;
            if (!props.side || adapter.isSameMonth(newModel[0], newModel[1])) {
              const closest = findClosestDate(date, newModel);
              index = newModel.indexOf(closest);
            } else {
              index = props.side === "start" ? 0 : props.side === "end" ? 1 : void 0;
            }
            newModel = newModel.map((v, i) => i === index ? date : v);
          } else {
            if (newModel[0] && adapter.isBefore(newModel[0], date)) {
              newModel = [newModel[0], date];
            } else {
              newModel = [date, newModel[0]];
            }
          }
        }
      } else {
        newModel = [date];
      }
      emit("update:modelValue", newModel.filter((v) => !!v));
    }
    const daysRef = ref();
    function findElement(el) {
      if (!el || el === daysRef.value)
        return null;
      if ("vDate" in el.dataset) {
        return adapter.date(el.dataset.vDate);
      }
      return findElement(el.parentElement);
    }
    function findDate(e) {
      var _a, _b;
      const x = "changedTouches" in e ? (_a = e.changedTouches[0]) == null ? void 0 : _a.clientX : e.clientX;
      const y = "changedTouches" in e ? (_b = e.changedTouches[0]) == null ? void 0 : _b.clientY : e.clientY;
      const el = document.elementFromPoint(x, y);
      return findElement(el);
    }
    let canDrag = false;
    function handleMousedown(e) {
      hasScrolled.value = false;
      const selected = findDate(e);
      if (!selected)
        return;
      const modelIndex = props.modelValue.findIndex((d) => adapter.isEqual(d, selected));
      if (modelIndex >= 0) {
        canDrag = true;
        dragHandle.value = modelIndex;
        window.addEventListener("touchmove", handleTouchmove, {
          passive: false
        });
        window.addEventListener("mousemove", handleTouchmove, {
          passive: false
        });
        e.preventDefault();
      }
      window.addEventListener("touchend", handleTouchend, {
        passive: false
      });
      window.addEventListener("mouseup", handleTouchend, {
        passive: false
      });
    }
    function handleTouchmove(e) {
      if (!canDrag)
        return;
      e.preventDefault();
      isDragging.value = true;
      const over = findDate(e);
      if (!over)
        return;
      selectDate(over);
    }
    function handleTouchend(e) {
      if (e.cancelable)
        e.preventDefault();
      window.removeEventListener("touchmove", handleTouchmove);
      window.removeEventListener("mousemove", handleTouchmove);
      window.removeEventListener("touchend", handleTouchend);
      window.removeEventListener("mouseup", handleTouchend);
      const end = findDate(e);
      if (!end)
        return;
      if (!hasScrolled.value) {
        selectDate(end);
      }
      isDragging.value = false;
      dragHandle.value = null;
      canDrag = false;
    }
    return () => createVNode("div", {
      "class": "v-date-picker-month"
    }, [props.showWeek && createVNode("div", {
      "key": "weeks",
      "class": "v-date-picker-month__weeks"
    }, [!props.hideWeekdays && createVNode("div", {
      "key": "hide-week-days",
      "class": "v-date-picker-month__day"
    }, [createTextVNode(" ")]), weeks.value.map((week) => createVNode("div", {
      "class": ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
    }, [week]))]), createVNode("div", {
      "ref": daysRef,
      "class": "v-date-picker-month__days",
      "onMousedown": handleMousedown,
      "onTouchstart": handleMousedown
    }, [!props.hideWeekdays && adapter.getWeekdays().map((weekDay) => createVNode("div", {
      "class": ["v-date-picker-month__day", "v-date-picker-month__weekday"]
    }, [weekDay])), daysInMonth.value.map((item, index) => {
      const color = item.isSelected || item.isToday ? props.color : item.isHovered || item.isDisabled ? void 0 : "transparent";
      const variant = item.isDisabled ? "text" : (item.isToday || item.isHovered) && !item.isSelected ? "outlined" : "flat";
      return createVNode("div", {
        "class": ["v-date-picker-month__day", {
          "v-date-picker-month__day--selected": item.isSelected,
          "v-date-picker-month__day--start": item.isStart,
          "v-date-picker-month__day--end": item.isEnd,
          "v-date-picker-month__day--adjacent": item.isAdjacent,
          "v-date-picker-month__day--hide-adjacent": item.isHidden,
          "v-date-picker-month__day--week-start": item.isWeekStart,
          "v-date-picker-month__day--week-end": item.isWeekEnd,
          "v-date-picker-month__day--hovered": item.isHovered
        }],
        "data-v-date": !item.isHidden && !item.isDisabled ? item.isoDate : void 0
      }, [item.inRange && createVNode("div", {
        "key": "in-range",
        "class": ["v-date-picker-month__day--range", backgroundColorClasses.value],
        "style": backgroundColorStyles.value
      }, null), item.inHover && !item.isStart && !item.isEnd && !item.isHovered && !item.inRange && createVNode("div", {
        "key": "in-hover",
        "class": "v-date-picker-month__day--hover"
      }, null), (props.showAdjacentMonths || !item.isAdjacent) && createVNode(VBtn, {
        "color": !item.isToday || item.isSelected ? color : void 0,
        "disabled": item.isDisabled,
        "icon": true,
        "ripple": false,
        "variant": variant
      }, {
        default: () => [item.localized]
      })]);
    })])]);
  }
});

// node_modules/vuetify/lib/labs/VDatePicker/VDatePickerYears.mjs
import "/Users/Quentin/itsa-team-five/node_modules/vuetify/lib/labs/VDatePicker/VDatePickerYears.css";
var makeVDatePickerYearsProps = propsFactory({
  color: String,
  height: [String, Number],
  displayDate: null,
  min: [Number, String, Date],
  max: [Number, String, Date]
}, "VDatePickerYears");
var VDatePickerYears = genericComponent()({
  name: "VDatePickerYears",
  props: makeVDatePickerYearsProps(),
  emits: {
    "update:displayDate": (date) => true,
    "click:mode": () => true
  },
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const adapter = useDate();
    const displayYear = computed(() => adapter.getYear(props.displayDate ?? /* @__PURE__ */ new Date()));
    const years = computed(() => {
      const min = props.min ? adapter.date(props.min).getFullYear() : displayYear.value - 100;
      const max = props.max ? adapter.date(props.max).getFullYear() : displayYear.value + 50;
      return createRange(max - min + 1, min);
    });
    const yearRef = ref();
    onMounted(() => {
      var _a;
      (_a = yearRef.value) == null ? void 0 : _a.$el.scrollIntoView({
        block: "center"
      });
    });
    useRender(() => createVNode("div", {
      "class": "v-date-picker-years",
      "style": {
        height: convertToUnit(props.height)
      }
    }, [createVNode("div", {
      "class": "v-date-picker-years__content"
    }, [years.value.map((year) => {
      function onClick() {
        emit("update:displayDate", adapter.setYear(props.displayDate, year));
        emit("click:mode");
      }
      return createVNode(VBtn, {
        "ref": year === displayYear.value ? yearRef : void 0,
        "active": year === displayYear.value,
        "color": year === displayYear.value ? props.color : void 0,
        "rounded": "xl",
        "text": String(year),
        "variant": year === displayYear.value ? "flat" : "text",
        "onClick": onClick
      }, null);
    })])]));
    return {};
  }
});

// node_modules/vuetify/lib/labs/VDatePicker/VDateCard.mjs
var makeVDateCardProps = propsFactory({
  cancelText: {
    type: String,
    default: "$vuetify.datePicker.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.datePicker.ok"
  },
  inputMode: {
    type: String,
    default: "calendar"
  },
  hideActions: Boolean,
  ...makeVDatePickerControlsProps(),
  ...makeVDatePickerMonthProps(),
  ...makeVDatePickerYearsProps(),
  ...makeTransitionProps({
    transition: {
      component: VFadeTransition,
      leaveAbsolute: true
    }
  })
}, "VDateCard");
var VDateCard = genericComponent()({
  name: "VDateCard",
  props: makeVDateCardProps(),
  emits: {
    save: () => true,
    cancel: () => true,
    "update:displayDate": (value) => true,
    "update:inputMode": (value) => true,
    "update:modelValue": (value) => true,
    "update:viewMode": (mode) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const {
      t
    } = useLocale();
    createDatePicker(props);
    function onDisplayUpdate(val) {
      emit("update:displayDate", val);
    }
    function onViewModeUpdate(val) {
      emit("update:viewMode", val);
    }
    function onSave() {
      emit("update:modelValue", model.value);
      emit("save");
    }
    function onCancel() {
      emit("cancel");
    }
    useRender(() => {
      const [cardProps] = VCard.filterProps(props);
      const [datePickerControlsProps] = VDatePickerControls.filterProps(props);
      const [datePickerMonthProps] = VDatePickerMonth.filterProps(props);
      const [datePickerYearsProps] = VDatePickerYears.filterProps(props);
      const hasActions = !props.hideActions || !!slots.actions;
      return createVNode(VCard, mergeProps(cardProps, {
        "class": "v-date-card"
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VDatePickerControls, mergeProps(datePickerControlsProps, {
          "onUpdate:displayDate": onDisplayUpdate,
          "onUpdate:viewMode": onViewModeUpdate
        }), null), createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          default: () => [props.viewMode === "month" ? createVNode(VDatePickerMonth, mergeProps(datePickerMonthProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "onUpdate:displayDate": onDisplayUpdate
          }), null) : createVNode(VDatePickerYears, mergeProps(datePickerYearsProps, {
            "onUpdate:displayDate": onDisplayUpdate,
            "onUpdate:viewMode": onViewModeUpdate
          }), null)]
        })]),
        actions: !hasActions ? void 0 : () => {
          var _a;
          return createVNode(Fragment, null, [((_a = slots.actions) == null ? void 0 : _a.call(slots)) ?? createVNode(Fragment, null, [createVNode(VBtn, {
            "onClick": onCancel,
            "text": t(props.cancelText)
          }, null), createVNode(VBtn, {
            "onClick": onSave,
            "text": t(props.okText)
          }, null)])]);
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VDatePicker/VDatePicker.mjs
import "/Users/Quentin/itsa-team-five/node_modules/vuetify/lib/labs/VDatePicker/VDatePicker.css";

// node_modules/vuetify/lib/labs/VDatePicker/VDatePickerHeader.mjs
import "/Users/Quentin/itsa-team-five/node_modules/vuetify/lib/labs/VDatePicker/VDatePickerHeader.css";
var makeVDatePickerHeaderProps = propsFactory({
  appendIcon: String,
  color: String,
  header: String,
  transition: String,
  onClick: EventProp()
}, "VDatePickerHeader");
var VDatePickerHeader = genericComponent()({
  name: "VDatePickerHeader",
  props: makeVDatePickerHeaderProps(),
  emits: {
    click: () => true,
    "click:append": () => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props, "color");
    function onClick() {
      emit("click");
    }
    function onClickAppend() {
      emit("click:append");
    }
    useRender(() => {
      const hasContent = !!(slots.default || props.header);
      const hasAppend = !!(slots.append || props.appendIcon);
      return createVNode("div", {
        "class": ["v-date-picker-header", {
          "v-date-picker-header--clickable": !!props.onClick
        }, backgroundColorClasses.value],
        "style": backgroundColorStyles.value,
        "onClick": onClick
      }, [slots.prepend && createVNode("div", {
        "key": "prepend",
        "class": "v-date-picker-header__prepend"
      }, [slots.prepend()]), hasContent && createVNode(MaybeTransition, {
        "key": "content",
        "name": props.transition
      }, {
        default: () => {
          var _a;
          return [createVNode("div", {
            "key": props.header,
            "class": "v-date-picker-header__content"
          }, [((_a = slots.default) == null ? void 0 : _a.call(slots)) ?? props.header])];
        }
      }), hasAppend && createVNode("div", {
        "class": "v-date-picker-header__append"
      }, [!slots.append ? createVNode(VBtn, {
        "key": "append-btn",
        "icon": props.appendIcon,
        "variant": "text",
        "onClick": onClickAppend
      }, null) : createVNode(VDefaultsProvider, {
        "key": "append-defaults",
        "disabled": !props.appendIcon,
        "defaults": {
          VBtn: {
            icon: props.appendIcon,
            variant: "text"
          }
        }
      }, {
        default: () => {
          var _a;
          return [(_a = slots.append) == null ? void 0 : _a.call(slots)];
        }
      })])]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VPicker/VPicker.mjs
import "/Users/Quentin/itsa-team-five/node_modules/vuetify/lib/labs/VPicker/VPicker.css";

// node_modules/vuetify/lib/labs/VPicker/VPickerTitle.mjs
var VPickerTitle = createSimpleFunctional("v-picker-title");

// node_modules/vuetify/lib/labs/VPicker/VPicker.mjs
var makeVPickerProps = propsFactory({
  bgColor: String,
  landscape: Boolean,
  title: String,
  ...makeVSheetProps()
}, "VPicker");
var VPicker = genericComponent()({
  name: "VPicker",
  props: makeVPickerProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    useRender(() => {
      const [sheetProps] = VSheet.filterProps(props);
      const hasTitle = !!(props.title || slots.title);
      return createVNode(VSheet, mergeProps(sheetProps, {
        "color": props.bgColor,
        "class": ["v-picker", {
          "v-picker--landscape": props.landscape,
          "v-picker--with-actions": !!slots.actions
        }, props.class],
        "style": props.style
      }), {
        default: () => {
          var _a, _b, _c;
          return [createVNode("div", {
            "class": [backgroundColorClasses.value],
            "style": [backgroundColorStyles.value]
          }, [hasTitle && createVNode(VPickerTitle, {
            "key": "picker-title"
          }, {
            default: () => {
              var _a2;
              return [((_a2 = slots.title) == null ? void 0 : _a2.call(slots)) ?? props.title];
            }
          }), slots.header && createVNode("div", {
            "class": "v-picker__header"
          }, [slots.header()])]), createVNode("div", {
            "class": "v-picker__body"
          }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), ((_c = (_b = slots.actions) == null ? void 0 : _b.call(slots)[0]) == null ? void 0 : _c.children) && createVNode("div", {
            "class": "v-picker__actions"
          }, [slots.actions()])];
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VDatePicker/VDatePicker.mjs
var makeVDatePickerProps = propsFactory({
  calendarIcon: {
    type: String,
    default: "$calendar"
  },
  keyboardIcon: {
    type: String,
    default: "$edit"
  },
  cancelText: {
    type: String,
    default: "$vuetify.datePicker.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.datePicker.ok"
  },
  inputText: {
    type: String,
    default: "$vuetify.datePicker.input.placeholder"
  },
  inputPlaceholder: {
    type: String,
    default: "dd/mm/yyyy"
  },
  header: {
    type: String,
    default: "$vuetify.datePicker.header"
  },
  hideActions: Boolean,
  ...makeDateProps2(),
  ...makeVDatePickerControlsProps(),
  ...makeVDatePickerMonthProps(),
  ...makeVDatePickerYearsProps(),
  ...makeVPickerProps({
    title: "$vuetify.datePicker.title"
  })
}, "VDatePicker");
var VDatePicker = genericComponent()({
  name: "VDatePicker",
  props: makeVDatePickerProps(),
  emits: {
    "click:cancel": () => true,
    "click:save": () => true,
    ...dateEmits
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const adapter = useDate();
    const {
      t
    } = useLocale();
    const {
      model,
      displayDate,
      viewMode,
      inputMode,
      isEqual
    } = createDatePicker(props);
    const isReversing = shallowRef(false);
    const inputModel = ref(model.value.map((date) => adapter.format(date, "keyboardDate")));
    const temporaryModel = ref(model.value);
    const title = computed(() => {
      return props.variant === "modern" ? t(props.title) : adapter.format(displayDate.value, "shortDate");
    });
    const header = computed(() => model.value.length ? adapter.format(model.value[0], "normalDateWithWeekday") : t(props.header));
    const headerIcon = computed(() => inputMode.value === "calendar" ? props.keyboardIcon : props.calendarIcon);
    const headerTransition = computed(() => `date-picker-header${isReversing.value ? "-reverse" : ""}-transition`);
    const minDate = computed(() => props.min && adapter.isValid(props.min) ? adapter.date(props.min) : null);
    const maxDate = computed(() => props.max && adapter.isValid(props.max) ? adapter.date(props.max) : null);
    const disabled = computed(() => {
      var _a, _b;
      if (!minDate.value && !maxDate.value)
        return false;
      const targets = [];
      if (minDate.value) {
        const date = adapter.addDays(adapter.startOfMonth(displayDate.value), -1);
        adapter.isAfter(minDate.value, date) && targets.push("prev");
      }
      if (maxDate.value) {
        const date = adapter.addDays(adapter.endOfMonth(displayDate.value), 1);
        adapter.isAfter(date, maxDate.value) && targets.push("next");
      }
      if (((_a = minDate.value) == null ? void 0 : _a.getFullYear()) === ((_b = maxDate.value) == null ? void 0 : _b.getFullYear())) {
        targets.push("mode");
      }
      return targets;
    });
    watch(model, (val) => {
      if (!isEqual(val, temporaryModel.value)) {
        temporaryModel.value = val;
      }
      inputModel.value = val.map((date) => adapter.format(date, "keyboardDate"));
    });
    watch(temporaryModel, (val, oldVal) => {
      if (props.hideActions && !isEqual(val, model.value)) {
        model.value = val;
      }
      if (val[0] && oldVal[0]) {
        isReversing.value = adapter.isBefore(val[0], oldVal[0]);
      }
    });
    function updateFromInput(input, index) {
      const {
        isValid,
        date,
        isAfter
      } = adapter;
      const inputDate = date(input);
      if (isValid(input) && (!minDate.value || !isAfter(minDate.value, inputDate)) && (!maxDate.value || !isAfter(inputDate, maxDate.value))) {
        const newModel = model.value.slice();
        newModel[index] = date(input);
        if (props.hideActions) {
          model.value = newModel;
        } else {
          temporaryModel.value = newModel;
        }
      }
    }
    function onClickCancel() {
      emit("click:cancel");
    }
    function onClickSave() {
      emit("click:save");
      model.value = temporaryModel.value;
    }
    function onClickAppend() {
      inputMode.value = inputMode.value === "calendar" ? "keyboard" : "calendar";
    }
    function onClickNext() {
      displayDate.value = adapter.addMonths(displayDate.value, 1);
    }
    function onClickPrev() {
      displayDate.value = adapter.addMonths(displayDate.value, -1);
    }
    function onClickMode() {
      viewMode.value = viewMode.value === "month" ? "year" : "month";
    }
    function onClickHeader() {
      viewMode.value = "month";
    }
    const headerSlotProps = computed(() => ({
      header: header.value,
      appendIcon: headerIcon.value,
      transition: headerTransition.value,
      "onClick:append": onClickAppend
    }));
    useRender(() => {
      const [pickerProps] = VPicker.filterProps(props);
      const [datePickerControlsProps] = VDatePickerControls.filterProps(props);
      const [datePickerMonthProps] = VDatePickerMonth.filterProps(props);
      const [datePickerYearsProps] = VDatePickerYears.filterProps(props);
      return createVNode(VPicker, mergeProps(pickerProps, {
        "class": ["v-date-picker", `v-date-picker--${viewMode.value}`, props.class],
        "style": props.style,
        "width": props.showWeek ? 408 : 360
      }), {
        title: () => {
          var _a;
          return ((_a = slots.title) == null ? void 0 : _a.call(slots)) ?? createVNode("div", {
            "class": "v-date-picker__title",
            "onClick": props.variant === "classic" ? onClickMode : void 0
          }, [title.value]);
        },
        header: () => {
          var _a;
          return ((_a = slots.header) == null ? void 0 : _a.call(slots, headerSlotProps.value)) ?? createVNode(VDatePickerHeader, mergeProps({
            "key": "header"
          }, headerSlotProps.value, {
            "onClick": viewMode.value === "year" ? onClickHeader : void 0
          }), null);
        },
        default: () => inputMode.value === "calendar" ? createVNode(Fragment, null, [(props.variant !== "classic" || viewMode.value !== "year") && createVNode(VDatePickerControls, mergeProps(datePickerControlsProps, {
          "disabled": disabled.value,
          "displayDate": adapter.format(displayDate.value, "monthAndYear"),
          "onClick:next": onClickNext,
          "onClick:prev": onClickPrev,
          "onClick:mode": onClickMode
        }), null), createVNode(VFadeTransition, {
          "hideOnLeave": true
        }, {
          default: () => [viewMode.value === "month" ? createVNode(VDatePickerMonth, mergeProps({
            "key": "date-picker-month"
          }, datePickerMonthProps, {
            "modelValue": temporaryModel.value,
            "onUpdate:modelValue": ($event) => temporaryModel.value = $event,
            "displayDate": displayDate.value,
            "min": minDate.value,
            "max": maxDate.value
          }), null) : createVNode(VDatePickerYears, mergeProps({
            "key": "date-picker-years"
          }, datePickerYearsProps, {
            "displayDate": displayDate.value,
            "onUpdate:displayDate": ($event) => displayDate.value = $event,
            "min": minDate.value,
            "max": maxDate.value,
            "onClick:mode": onClickMode
          }), null)]
        })]) : createVNode("div", {
          "class": "v-date-picker__input"
        }, [createVNode(VTextField, {
          "modelValue": inputModel.value[0],
          "onUpdate:modelValue": (v) => updateFromInput(v, 0),
          "label": t(props.inputText),
          "placeholder": props.inputPlaceholder
        }, null)]),
        actions: () => !props.hideActions ? createVNode("div", null, [createVNode(VBtn, {
          "variant": "text",
          "color": props.color,
          "onClick": onClickCancel,
          "text": t(props.cancelText)
        }, null), createVNode(VBtn, {
          "variant": "text",
          "color": props.color,
          "onClick": onClickSave,
          "text": t(props.okText)
        }, null)]) : void 0
      });
    });
    return {};
  }
});
export {
  VDateCard,
  VDatePicker,
  VDatePickerControls,
  VDatePickerHeader,
  VDatePickerMonth,
  VDatePickerYears
};
//# sourceMappingURL=vuetify_labs_VDatePicker.js.map
