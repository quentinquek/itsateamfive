import {
  VOverlay
} from "./chunk-D6YRVQ4A.js";
import {
  VField,
  makeVFieldProps
} from "./chunk-XV4QSM4Q.js";
import {
  makeFocusProps,
  useFocus
} from "./chunk-GS4XGHAZ.js";
import "./chunk-GUDXS3QS.js";
import {
  VProgressCircular
} from "./chunk-PERYJOTZ.js";
import "./chunk-NCIFIG5Y.js";
import "./chunk-QHPYAADC.js";
import {
  makeDimensionProps,
  useDimension
} from "./chunk-BYYOIPT2.js";
import "./chunk-UBU4KZUY.js";
import "./chunk-6OIYN6EE.js";
import "./chunk-2T3QEACQ.js";
import "./chunk-J4QSHRDK.js";
import "./chunk-C3XADYCL.js";
import {
  useLocale
} from "./chunk-NMRZ4LPY.js";
import {
  useProxiedModel
} from "./chunk-4BWECWI4.js";
import "./chunk-TDSCPXFT.js";
import "./chunk-MIKYVDLZ.js";
import "./chunk-OB5CTQGT.js";
import "./chunk-Q6VPMTLA.js";
import "./chunk-34YJHVVI.js";
import "./chunk-2V56JD5T.js";
import "./chunk-X7E5QEKA.js";
import {
  IN_BROWSER,
  filterInputAttrs,
  focusChild,
  genericComponent,
  only,
  propsFactory,
  provideDefaults,
  useRender
} from "./chunk-DB4WMXLI.js";
import {
  Fragment,
  computed,
  createVNode,
  mergeProps,
  ref,
  watch
} from "./chunk-Y7RJFRXZ.js";
import "./chunk-CO2D5T6V.js";

// node_modules/vuetify/lib/labs/VOtpInput/VOtpInput.mjs
import "/Users/Quentin/itsa-team-five/node_modules/vuetify/lib/labs/VOtpInput/VOtpInput.css";
var makeVOtpInputProps = propsFactory({
  autofocus: Boolean,
  divider: String,
  focusAll: Boolean,
  label: {
    type: String,
    default: "$vuetify.input.otp"
  },
  length: {
    type: [Number, String],
    default: 6
  },
  modelValue: {
    type: [Number, String],
    default: void 0
  },
  placeholder: String,
  type: {
    type: String,
    default: "text"
  },
  ...makeDimensionProps(),
  ...makeFocusProps(),
  ...only(makeVFieldProps({
    variant: "outlined"
  }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])
}, "VOtpInput");
var VOtpInput = genericComponent()({
  name: "VOtpInput",
  props: makeVOtpInputProps(),
  emits: {
    finish: (val) => true,
    "update:focused": (val) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const model = useProxiedModel(props, "modelValue", "", (val) => String(val).split(""), (val) => val.join(""));
    const {
      t
    } = useLocale();
    const fields = computed(() => Array(Number(props.length)).fill(0));
    const focusIndex = ref(-1);
    const contentRef = ref();
    const inputRef = ref([]);
    const current = computed(() => inputRef.value[focusIndex.value]);
    function onInput() {
      const array = model.value.slice();
      const value = current.value.value;
      array[focusIndex.value] = value;
      model.value = array;
      let target = null;
      if (focusIndex.value > model.value.length) {
        target = model.value.length + 1;
      } else if (focusIndex.value + 1 !== Number(props.length)) {
        target = "next";
      } else {
        requestAnimationFrame(() => {
          var _a;
          return (_a = current.value) == null ? void 0 : _a.blur();
        });
      }
      if (target)
        focusChild(contentRef.value, target);
    }
    function onKeydown(e) {
      const array = model.value.slice();
      const index = focusIndex.value;
      let target = null;
      if (!["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(e.key))
        return;
      e.preventDefault();
      if (e.key === "ArrowLeft") {
        target = "prev";
      } else if (e.key === "ArrowRight") {
        target = "next";
      } else if (["Backspace", "Delete"].includes(e.key)) {
        array[focusIndex.value] = "";
        model.value = array;
        if (focusIndex.value > 0 && e.key === "Backspace") {
          target = "prev";
        } else {
          requestAnimationFrame(() => {
            inputRef.value[index].select();
          });
        }
      }
      requestAnimationFrame(() => {
        if (target != null) {
          focusChild(contentRef.value, target);
        }
      });
    }
    function onPaste(index, e) {
      var _a, _b;
      e.preventDefault();
      e.stopPropagation();
      model.value = (((_a = e == null ? void 0 : e.clipboardData) == null ? void 0 : _a.getData("Text")) ?? "").split("");
      (_b = inputRef.value) == null ? void 0 : _b[index].blur();
    }
    function reset() {
      model.value = [];
    }
    function onFocus(e, index) {
      focus();
      focusIndex.value = index;
    }
    function onBlur() {
      blur();
      focusIndex.value = -1;
    }
    provideDefaults({
      VField: {
        disabled: computed(() => props.disabled),
        error: computed(() => props.error),
        variant: computed(() => props.variant)
      }
    }, {
      scoped: true
    });
    watch(model, (val) => {
      if (val.length === props.length)
        emit("finish", val.join(""));
    }, {
      deep: true
    });
    watch(focusIndex, (val) => {
      if (val < 0)
        return;
      IN_BROWSER && window.requestAnimationFrame(() => {
        inputRef.value[val].select();
      });
    });
    useRender(() => {
      var _a;
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      return createVNode("div", mergeProps({
        "class": ["v-otp-input", {
          "v-otp-input--divided": !!props.divider
        }, props.class],
        "style": [props.style]
      }, rootAttrs), [createVNode("div", {
        "ref": contentRef,
        "class": "v-otp-input__content",
        "style": [dimensionStyles.value]
      }, [fields.value.map((_, i) => createVNode(Fragment, null, [props.divider && i !== 0 && createVNode("span", {
        "class": "v-otp-input__divider"
      }, [props.divider]), createVNode(VField, {
        "focused": isFocused.value && props.focusAll || focusIndex.value === i,
        "key": i
      }, {
        ...slots,
        default: () => {
          return createVNode("input", {
            "ref": (val) => inputRef.value[i] = val,
            "aria-label": t(props.label, i + 1),
            "autofocus": i === 0 && props.autofocus,
            "autocomplete": "one-time-code",
            "class": ["v-otp-input__field"],
            "inputmode": "text",
            "min": props.type === "number" ? 0 : void 0,
            "maxlength": "1",
            "placeholder": props.placeholder,
            "type": props.type,
            "value": model.value[i],
            "onInput": onInput,
            "onFocus": (e) => onFocus(e, i),
            "onBlur": onBlur,
            "onKeydown": onKeydown,
            "onPaste": (event) => onPaste(i, event)
          }, null);
        }
      })])), createVNode("input", mergeProps({
        "class": "v-otp-input-input",
        "type": "hidden"
      }, inputAttrs, {
        "value": model.value.join("")
      }), null), createVNode(VOverlay, {
        "contained": true,
        "content-class": "v-otp-input__loader",
        "model-value": !!props.loading,
        "persistent": true
      }, {
        default: () => {
          var _a2;
          return [((_a2 = slots.loader) == null ? void 0 : _a2.call(slots)) ?? createVNode(VProgressCircular, {
            "color": typeof props.loading === "boolean" ? void 0 : props.loading,
            "indeterminate": true,
            "size": "24",
            "width": "2"
          }, null)];
        }
      }), (_a = slots.default) == null ? void 0 : _a.call(slots)])]);
    });
    return {
      blur: () => {
        var _a;
        (_a = inputRef.value) == null ? void 0 : _a.some((input) => input.blur());
      },
      focus: () => {
        var _a;
        (_a = inputRef.value) == null ? void 0 : _a[0].focus();
      },
      reset,
      isFocused
    };
  }
});
export {
  VOtpInput
};
//# sourceMappingURL=vuetify_labs_VOtpInput.js.map
